# -*- coding: utf-8 -*-
"""
Created on Tue May 12 18:59:21 2020

@authors G. Mastorakis, B. Lazaruk, J. Roberts
"""

"""
Standard is that the length is the x-axis, height is the y-axis, and width is the z-axis

"""

import numpy as np
import sys
import vtk
import avatars
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtCore import QFile, QTextStream, pyqtSignal

from vtk import vtkSphereSource,vtkAxesActor,vtkTransform,vtkRenderer,vtkColorTransferFunction,vtkPoints,vtkCellArray,vtkUnsignedCharArray,vtkPolygon,vtkPolyData,VTK_MAJOR_VERSION,vtkPolyDataMapper,vtkActor,vtkProperty,vtkScalarBarActor,vtkActorCollection
from vtk.qt.QVTKRenderWindowInteractor import QVTKRenderWindowInteractor  
       

import vPlanGUI_v012 # qt gui, read-only and generated by xml in test1.ui
import breeze_resources # dark gui
import vis as graphics # local library, drawing functions of cubes etc
from vis import colours, opacities    # the colour and opacity settings, stored in vis.py so they need only be changed once

# import sokoban as sb

#imports for the simulation of each domain

import process_action_sok as pask

import drone_sim as dr

import annotate
import add_walls
import floormethods
import scanScene
import generatePDDL


# Build the renderers container
# It's occasionally useful to repeat actions on all the renderers
# and also it's important to add them in the same order
# so storing them in a container makes those things much easier
renderers = []
countOfRenderers = 3
for i in range(countOfRenderers):
    renderers.append(vtkRenderer())

# id the element of the the renderers
annotations = 2
pointers = 1
blocks = 0

# Initialize the "stack" to be used to hold undoSets and enable the undo functions
undoStack = []

# Initialize the "stack" to be used to hold redoSets and enable the redo functions
redoStack = []

def commitAction(collection):
    # Adding a new step to the undoStack invalidates anything that is currently in the redoStack, so clear it out
    # Commit the new collection to the undoStack
    undoStack.append(collection)
    # Clear out the redoStack
    redoStack.clear()

class deleteGeometryStyle(vtk.vtkInteractorStyleTrackballCamera):
    def __init__(self, renderWindow, parent=None):
        self.AddObserver("LeftButtonPressEvent", self.leftButtonPressEvent)
        self.renderWindow = renderWindow

    def leftButtonPressEvent(self,obj,event):
        # Prep undoSet
        undoSet = ['addactor', blocks]
        # Get the position of the click
        clickPos = self.GetInteractor().GetEventPosition()
        # Set up the proppicker
        picker = vtk.vtkPropPicker()
        # Perform the pick on the designated renderer
        pickCheck = picker.PickProp(clickPos[0], clickPos[1], renderers[blocks])
        # Only proceed if something was clicked on.
        if pickCheck == 1:
            # An actor / floor, or prop / wall was selected, and so can be deleted.
            # Push this into the undoSet
            undoSet.append(picker.GetViewProp())
            # And remove the picked actor from the renderer
            renderers[blocks].RemoveActor(picker.GetViewProp())
            # After all the operations are completed, encapsulate the undoSet into an undoCollection, and push the undoCollection to the undoStack
            # If there is something in the undoSet that is
            if len(undoSet) > 2:
                undoCollection = []
                undoCollection.append(undoSet)
                commitAction(undoCollection)
        # Update the renderer
        self.renderWindow.Render()
        return

class pickerStyle(vtk.vtkInteractorStyleTrackballCamera):
    # This is the new pickerStyle where we are just moving a yellow marker around the scene and updating the spinners instead of manipulating the scene
    def __init__(self, renderWindow, spinX, spinY, spinZ, angle, parent=None):
        self.AddObserver("LeftButtonPressEvent", self.leftButtonPressEvent)
        self.spinXref = spinX
        self.spinYref = spinY
        self.spinZref = spinZ
        self.angleRef = angle
        self.pointer = None
        self.spinXref.valueChanged.connect(self.spinnerChanged)
        self.spinYref.valueChanged.connect(self.spinnerChanged)
        self.spinZref.valueChanged.connect(self.spinnerChanged)
        self.renderWindow = renderWindow

    def spinnerChanged(self):
        # If there is a pointer then remove it
        self.removePointer()
        # And create a pointer where the spinners are set to
        tx = int(self.spinXref.value())
        ty = int(self.spinYref.value())
        tz = int(self.spinZref.value())
        self.addPointer(tx, ty, tz)
        self.renderWindow.Render()

    def removePointer(self):
        if self.pointer != None:
            renderers[pointers].RemoveActor(self.pointer)

    def addPointer(self, x, y, z):
        self.pointer = graphics.pointer(x, y, z, 0.1)
        # Add the pointer to the renderer
        renderers[pointers].AddActor(self.pointer)

    def leftButtonPressEvent(self, obj, event):
        # Gather the location of the click
        clickPos = self.GetInteractor().GetEventPosition()
        # Pick the scene at that position
        picker = vtk.vtkPropPicker()
        pick = picker.PickProp(clickPos[0], clickPos[1], renderers[blocks])
        # If something was picked in the scene, continue
        if pick == 1:
            # First, if the pointer already exists then remove it as we're building a new one
            self.removePointer()
            # Now read the position of the prop that was picked
            tx, ty, tz = int(picker.GetViewProp().GetBounds()[1]), int(picker.GetViewProp().GetBounds()[3]), int(picker.GetViewProp().GetBounds()[5])
            # Create the pointer at that clicked location
            self.addPointer(tx, ty, tz)
            # Update the spinners to reflect the clicked location
            self.spinXref.setValue(tx)
            self.spinYref.setValue(ty)
            self.spinZref.setValue(tz)
        # Update the renderer
        self.renderWindow.Render()
        return

class createObstacleStyle(vtk.vtkInteractorStyleTrackballCamera):
    def __init__(self, renderWindow, obstacleX, obstacleY, obstacleZ, coordStatus, parent=None):
        self.AddObserver("LeftButtonPressEvent", self.leftButtonPressEvent)
        # Pass in the spinners by reference so they can be modified
        self.obstacleXref = obstacleX
        self.obstacleYref = obstacleY
        self.obstacleZref = obstacleZ
        self.pointer = None
        self.obstacleXref.valueChanged.connect(self.spinnerChanged)
        self.obstacleYref.valueChanged.connect(self.spinnerChanged)
        self.obstacleZref.valueChanged.connect(self.spinnerChanged)
        # add the spinnerChanged stuff here
        self.showCoords = coordStatus
        self.renderWindow = renderWindow

    def removePointer(self):
        if self.pointer != None:
            renderers[pointers].RemoveActor(self.pointer)

    def addPointer(self, x, y, z):
        self.pointer = graphics.pointer(x, y, z, 0.1)
        # Add the pointer to the renderer
        renderers[pointers].AddActor(self.pointer)

    def spinnerChanged(self):
        # If there is a pointer then remove it
        self.removePointer()
        # And create a pointer where the spinners are set to
        tx = int(self.obstacleXref.value())
        ty = int(self.obstacleYref.value())
        tz = int(self.obstacleZref.value())
        self.addPointer(tx, ty, tz)
        self.renderWindow.Render()

    def leftButtonPressEvent(self, obj, event):
        # Gather the location of the click
        clickPos = self.GetInteractor().GetEventPosition()
        # Pick the scene at that position
        picker = vtk.vtkPropPicker()
        pick = picker.PickProp(clickPos[0], clickPos[1], renderers[blocks])
        # If something was picked in the scene, continue
        if pick == 1:
            # First, if the pointer already exists then remove it as we're building a new one
            self.removePointer()
            # Now read the position of the prop that was picked
            tx, ty, tz = int(picker.GetViewProp().GetBounds()[1]), int(picker.GetViewProp().GetBounds()[3]), int(picker.GetViewProp().GetBounds()[5])
            # Create the pointer at that clicked location
            self.addPointer(tx, ty, tz)
            # Update the spinners to reflect the clicked location
            self.obstacleXref.setValue(tx)
            self.obstacleYref.setValue(ty)
            self.obstacleZref.setValue(tz)
        # Update the renderer
        self.renderWindow.Render()
        return

class MainWindow(QtWidgets.QMainWindow, vPlanGUI_v012.Ui_MainWindow):
    def __init__(self, parent = None):
        QtWidgets.QMainWindow.__init__(self, parent)
        self.setupUi(self)

        self.vtkWidget = QVTKRenderWindowInteractor(self)
        #self.vtkWidget.AddObserver("LeftButtonPressEvent",self.leftButtonPressEvent)
        self.mainLayout.addWidget(self.vtkWidget, 3)

        # loop through renderers and assign them the layer number of the order the exist in the list
        for i in range(len(renderers)):
            renderers[i].SetLayer(i)

        # Declare render window
        # Important to list the number of layers here
        self.renwin = self.vtkWidget.GetRenderWindow()
        self.renwin.SetNumberOfLayers(len(renderers))

        # Add renderers to the render window
        for i in range(len(renderers)):
            self.renwin.AddRenderer(renderers[i])

        self.iren = self.renwin.GetInteractor()
        self.style = vtk.vtkInteractorStyleTrackballCamera()
        self.style.SetDefaultRenderer(renderers[blocks])
        self.iren.SetInteractorStyle(self.style)

        # Axis transform
        # Move the object just a bit off the displayed axis so they don't overlap
        transform = vtkTransform()
        transform.Translate(-1.0, 0.0, -1.0)
        self.axes = vtkAxesActor()
        self.axes.SetUserTransform(transform)

        #grid - call vis
        self.gridG = graphics.structured_grid_2(100, 0.1, 100, 0.5)

        #qt gui interaction
        # toggle axis UI
        # self.axis.clicked.connect(self.set_axis)
        self.axis.clicked.connect(lambda: annotate.set_axis(self.renwin, renderers, annotations, self.axis, self.axes, ""))

        # toggle grid UI
        # self.grid.clicked.connect(self.set_grid)
        self.grid.clicked.connect(lambda: annotate.set_grid(self.renwin, renderers, annotations, self.grid, self.gridG, ""))

        # choose a camera position
        self.viewFront.clicked.connect(lambda: self.set_view(44, 6, 2))
        self.viewTop.clicked.connect(lambda: self.set_view(1, 85, 4))
        self.viewSide.clicked.connect(lambda: self.set_view(-18, 6, -27))

        # Activate various styles
        self.deleteGeom.clicked.connect(lambda: self.deleteGeometryBtnClicked())
        self.setObstacle.clicked.connect(lambda: self.obstacleBtnClicked())

        # "outside walls" UI
        self.setWallDims.clicked.connect(lambda: self.walls_floor(style ='out'))

        # Toggle coordinate captions
        # self.showCoords.clicked.connect(self.toggleCaptions)
        self.showCoords.clicked.connect(lambda: annotate.toggleCaptions(self.renwin, renderers, blocks, self.showCoords, self.progressBar, ""))

        # Toggle wall transparency
        self.transparencyWall.clicked.connect(lambda: annotate.toggleWallTransparency(self.renwin, renderers, blocks, self.transparencyWall, self.progressBar, ""))

        # keypress interactions
        self.iren.AddObserver("KeyPressEvent", self.Keypress)

        # "add walls parallel to Z walls" UI
        self.setInWalls2Z.clicked.connect(lambda: self.walls_floor(style ='2Z'))

        # "add walls parallel to X walls" UI
        self.setInWalls2X.clicked.connect(lambda: self.walls_floor(style ='2X'))

        # delete scene UI
        self.deleteAll.clicked.connect(self.deleteAllActors)

        # toggle floor UI
        # self.floor.clicked.connect(self.setFloor)
        self.floor.clicked.connect(lambda: floormethods.setFloor(self.renwin, renderers, blocks, self.floor, self.progressBar, ""))

        # undo button UI
        self.undoButton.clicked.connect(lambda: self.undoredo(operation = 'undo'))

        # redo button UI
        self.redoButton.clicked.connect(lambda: self.undoredo(operation = 'redo'))

        # input problem name for planning problem - PDDL
        self.problemName.textChanged.connect(self.printText)

        # input problem name for planning Domain - PDDL
        # set domain files in the drop menu - GUI
        self.domainName.addItem('Sokoban')
        self.domainName.addItem('Drone')

        # Load plan button (Jamie)
        self.openPlan.clicked.connect(self.openFileNameDialog)

        # (Jamie)
        # Load simulation - Use this to load the sim or else use the open button on the left - we can merge the functionalities later.
        self.loadSim.clicked.connect(self.loadSimulation)

        # get the settings from this renderer
        self.camera = renderers[0].GetActiveCamera()

        # make the initial camera settings on the first renderer
        renderers[0].ResetCamera()
        self.camera.SetFocalPoint(0.0,0.0,0.0)
        self.camera.SetPosition(10,0,-10)
        self.camera.SetViewUp(0.0,0.0,0.0)

        # set the camera for subsequent renderers to be the same camera as the first renderer
        for i in range(1, len(renderers)):
            renderers[i].SetActiveCamera(self.camera)

        # Save obstacle click
        self.saveObstacle.clicked.connect(lambda: self.walls_floor(style ='obstacle'))

        # Save entry or goal from spinners
        self.saveEntryGoal.clicked.connect(lambda: self.changeTypeFromSpinners(spinX=int(self.entryGoalX.value()), spinY=int(self.entryGoalY.value()), spinZ=int(self.entryGoalZ.value()), angle=int(self.entryGoalAngle.value())))

        # Generate PDDL Button Click
        self.genPDDL.clicked.connect(lambda: generatePDDL.writefile(renderers, blocks, str(self.domainName.currentText()), self.problemName.text(), self.elementsNumber.value()))

        # Preview PDDL Button Click
        self.previewPDDL.clicked.connect(lambda: generatePDDL.preview(renderers, blocks, str(self.domainName.currentText()), self.problemName.text(), self.elementsNumber.value()))

        self.playSim.clicked.connect(self.step_through_sim)

        self.iren.Start()

        self.planningComboBox.currentIndexChanged.connect(self.pcbChanged)

        # Dictionary of initial/default UI settings
        self.defaultUI = {
            'roomX': 10, 'roomY': 1, 'roomZ': 10,
            'wallParallel2X_W': 2, 'wallParallel2X_H': 1, 'wallParallel2X_D': 3,
            'wallParallel2Z_W': 2, 'wallParallel2Z_H': 2, 'wallParallel2Z_D': 2,
            'obstacleX': 2, 'obstacleY': 3, 'obstacleZ': 5,
            'undoSpinBox': 10, 'elementsNumber': 4,
            'entryGoalX': 0, 'entryGoalY': 0, 'entryGoalZ': 0, 'entryGoalAngle': 0,
            'floor': True, 'grid': False, 'axis': False, 'showCoords': False, 'transparencyWall': False,
            'domainName': 0, 'planningComboBox': 0, 'problemName': 'helloworld'
        }

        # Set the UI to the initial values
        self.writeUI(self.defaultUI)

    def disconnectAllSpinners(self):
       # Disconnect from all the spinners so that clicking on the scene doesn't update the spinners anymore
        spinners = [
            self.obstacleX,
            self.obstacleY,
            self.obstacleZ,
            self.entryGoalX,
            self.entryGoalY,
            self.entryGoalZ,
            self.entryGoalAngle
        ]
        for spinner in spinners:
            try:
                spinner.disconnect()
            except Exception:
                pass

    def clearStylesExcept(self, style):
        # Runs through the available styles and clears all except the one passed
        if style != 'obstacle':
            self.setObstacle.setChecked(False)
        if style != 'deleteGeom':
            self.deleteGeom.setChecked(False)
        if style != 'pcb':
            self.planningComboBox.setCurrentIndex(0)

    def pcbChanged(self, index):
        # Clear other style buttons
        self.clearStylesExcept(style='pcb')
        # As the planning combo box has changed from index 0 (select) to one of the planning options, enter the picker mode
        # When the user clicks Save then read the spinners and the text of the combo box index
        # Based on the index, set the colour to be set on the object at the location of the spinners
        # Then use self.planningComboBox.setCurrentIndex(0) to reset the combo box to index 0, and reset the camera
        if index != 0:
            # The index is not 0, which means we should switch to the mode which enables the updating of the spinners
            self.iren.SetInteractorStyle(pickerStyle(self.renwin, self.entryGoalX, self.entryGoalY, self.entryGoalZ, self.entryGoalAngle, True))
        else:
            # The index is 0, so we should be using the default viewing mode
            # Remove any existing pointers by clearing that renderer
            renderers[pointers].RemoveAllViewProps()
            self.disconnectAllSpinners()
            self.iren.SetInteractorStyle(self.style)
            self.renwin.Render()

    def obstacleBtnClicked(self):
        # When the Set Obstacle button is clicked
        # Clear other style buttons
        self.clearStylesExcept(style='obstacle')
        if self.setObstacle.isChecked():
            self.iren.SetInteractorStyle(createObstacleStyle(self.renwin, self.obstacleX, self.obstacleY, self.obstacleZ, self.showCoords))
        else:
            # Remove any existing pointers by clearing that renderer
            renderers[pointers].RemoveAllViewProps()
            self.disconnectAllSpinners()
            self.iren.SetInteractorStyle(self.style)
            self.renwin.Render()

    def deleteGeometryBtnClicked(self):
        # When the Delete Blocks button is clicked
        # Clear other style buttons
        self.clearStylesExcept(style='deleteGeom')
        if self.deleteGeom.isChecked():
            self.iren.SetInteractorStyle(deleteGeometryStyle(self.renwin))
        else:
            self.iren.SetInteractorStyle(self.style)
            self.renwin.Render()

    # Use this to load the simuation in a separate renderer - use this after importing a plan and before stepping through the simulation
    def loadSimulation(self):
    # If statement to indicate which domain name is loaded
       
        if self.domainName.currentText() == 'Sokoban':
            # Add the vtkActor instances of the simulation to the renderer
            #Example agent set-up using problem file
            # pl1: player
            pl1 = avatars.cube()
            pl1.set_dims(1,1,1)
            pl1.turn_blue()
            # st1 stone
            st1 = avatars.cube()
            st1.set_dims(1,1,1)
            st1.set_dims(1,1,1)
            st1.turn_orange()
            st2 = avatars.cube()
            st2.set_dims(1,1,1)
            st2.turn_orange()

            self.sim_agents = {'player-01':pl1,'stone-01':st1,'stone-02':st2}
            #agent position definition 
            pask.interpret_initial_pos(self.sim_agents,self.t_plan)

            for agent in self.sim_agents.values():
                renderers[blocks].AddActor(agent.get_actor())
            # Set the simulation 'tick'
            self.sim_tick = 0
            # Update Renderer
            self.renwin.Render()

        elif self.domainName.currentText() == 'Drone':
            print('loading drone plan...')
            # Add the vtkActor instances of the simulation to the renderer
            #Example agent set-up using problem file
            nDrones = 4
            # replaced nDrones as self.elementsNumber.value()
            self.sim_agents = dr.gen_drones(self.elementsNumber.value())
            for agent in self.sim_agents:
                renderers[blocks].AddActor(agent.get_actor())
            # Set the simulation 'tick'
            self.sim_tick = 0
            # Update Renderer
            self.renwin.Render()
            print('drone plan loaded!')

    def step_through_sim(self):
    # If statement to indicate which domain name is loaded

        if self.domainName.currentText() == 'Sokoban':
            #evaluate the current action from the relevant simulation class, the action will/should be implemented via the correct vtkActor
            if self.sim_tick>=len(self.t_plan):
                print('No More Actions in Plan')
            else:
                pask.action(self.t_plan[self.sim_tick],self.sim_agents)
                # update sim tick
                self.sim_tick += 1
                # update renderer
                self.renwin.Render()


        elif self.domainName.currentText() == 'Drone':
            #evaluate the current action from the relevant simulation class, the action will/should be implemented via the correct vtkActor
            if self.sim_tick>=len(self.t_plan):
                print('No More Actions in Plan')
            else:
                dr.action(self.t_plan[self.sim_tick],self.sim_agents)
                # update sim tick
                self.sim_tick += 1
                # update renderer
                self.renwin.Render()

    # used to load plan file (for now) (Jamie)
    def openFileNameDialog(self):
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        fileName, _ = QFileDialog.getOpenFileName(self,"QFileDialog.getOpenFileName()", "","CSV Files (*.csv)", options=options)

        if fileName:
           # import the file of the PDDL plan
            self.plan_to_sim = fileName

    # If statement to indicate which domain name is loaded
        if self.domainName.currentText() == 'Sokoban':

           self.plan = self.plan_to_sim
           self.t_plan = pask.read_plan(self.plan)

        elif self.domainName.currentText() == 'Drone':
    
           self.plan = self.plan_to_sim
           self.t_plan = dr.read_plan(self.plan)


        else:
            print('no domain selected')

    def printText(self):
        # this is to test the text input fields
        txt = self.problemName.text()

        print(txt)

    def saveUI(self):
        # Read all of the UI elements, by type, and save their names and current values to a dictionary
        # Then return the dictionary
        UIDictionary = {}
        # Collect all the UI objects
        qtSpinners = self.findChildren((QtWidgets.QSpinBox))
        qtCheckboxes = self.findChildren((QtWidgets.QCheckBox))
        qtComboboxes = self.findChildren((QtWidgets.QComboBox))
        qtLineboxes = self.findChildren((QtWidgets.QLineEdit))

        # Export the current UI settings to a dictionary
        for spinbox in qtSpinners:
            UIDictionary[spinbox.objectName()] = spinbox.value()
        for checkbox in qtCheckboxes:
            UIDictionary[checkbox.objectName()] = checkbox.isChecked()
        for combobox in qtComboboxes:
            UIDictionary[combobox.objectName()] = combobox.currentIndex()
        for linebox in qtLineboxes:
            if (linebox.objectName() != "qt_spinbox_lineedit"):
                UIDictionary[linebox.objectName()] = linebox.text()
        return UIDictionary

    def writeUI(self, UIDict):
        # Set the various UI spinners, checkboxes, lineboxes based on the passed dictionary
        # Collect all the UI objects
        qtSpinners = self.findChildren((QtWidgets.QSpinBox))
        qtCheckboxes = self.findChildren((QtWidgets.QCheckBox))
        qtComboboxes = self.findChildren((QtWidgets.QComboBox))
        qtLineboxes = self.findChildren((QtWidgets.QLineEdit))

        # Iterate on each list and update the values from the dictionary
        for spinbox in qtSpinners:
            # Using the name of the spinbox object as the key, set the spinbox to the value from the dictionary
            spinbox.setValue(UIDict[spinbox.objectName()])
        for checkbox in qtCheckboxes:
            # Using the name of the checkbox object as the key, set the checkbox to the state from the dictionary
            checkbox.setChecked(UIDict[checkbox.objectName()])
        for combobox in qtComboboxes:
            # Using the name of the combobox object as the key, set the combobox index to the value from the dictionary
            combobox.setCurrentIndex(UIDict[combobox.objectName()])
        for linebox in qtLineboxes:
            # Using the name of the lineedit object as the key, set the text to the value from the dictionary
            # Skip anything with the name of "qt_spinbox_lineedit" as those were captured with the spinbox loop above
            if (linebox.objectName() != "qt_spinbox_lineedit"):
                linebox.setText(UIDict[linebox.objectName()])

        # Add actors based on new UI settings
        if self.grid.isChecked() == True:
            renderers[annotations].AddActor(self.gridG)
        if self.axis.isChecked() == True:
            renderers[annotations].AddActor(self.axes)

        return

    def undoredo(self, operation):
        # undoredo works with two stacks, one for undo actions and the other for redo actions
        # First perform stack maintenance
        # Truncate sets from both stacks if they are longer than the maximum undoredostackdepth
        while len(undoStack) > self.undoSpinBox.value():
            # Use reverse to move the oldest item in the list to the end, then pop to remove it,
            # and then reverse again to move the newest item in the list back to the end of the list
            undoStack.reverse()
            undoStack.pop()
            undoStack.reverse()

        while len(redoStack) > self.undoSpinBox.value():
            # Use reverse to move the oldest item in the list to the end, then pop to remove it,
            # and then reverse again to move the newest item in the list back to the end of the list
            redoStack.reverse()
            redoStack.pop()
            redoStack.reverse()

        # Now define which stack is the source and which is the reverse, based on the user's action (undo or redo)
        if operation == 'undo':
            sourceStack = undoStack
            reverseStack = redoStack
        else:
            sourceStack = redoStack
            reverseStack = undoStack

        # Only do something if the sourceStack is populated
        if len(sourceStack) > 0:
            # Get the operation set from the sourceStack
            # Pop the newest collection from the list, which is equivalent to popping the head of a stack
            operationCollection = sourceStack.pop()

            # Prep the progress bar
            numberOfOperations = len(operationCollection)
            self.progressBar.setProperty("value", 0)
            iteration = 0
            # Set up the reverseCollection, which will be an inverse of each of the operationSets in this collection
            reverseCollection = []
            # Now iterate over the sets in the collection
            for operationSet in operationCollection:
                # The operation to be performed is element 0, and the renderer target is noted in element 1.
                # Subsequent elements are the actors to be operated with.
                operation, renderer, targets = operationSet[0], operationSet[1], operationSet[2:]
                # Setup the reverseSet to be pushed into the targetStack at the end of all operations
                reverseSet = ['', renderer]

                if operation == "removeactor":
                    # Actions to remove an actor from the scene
                    # Populate the reverseSet action
                    reverseSet[0] = "addactor"
                    for target in targets:
                        # Remove the actor
                        renderers[renderer].RemoveActor(target)
                        # And push the actor into the reverseSet
                        reverseSet.append(target)
                elif operation == "addactor":
                    # Actions to add an actor to the scene
                    # Populate the reverseSet action
                    reverseSet[0] = "removeactor"
                    for target in targets:
                        # Add the actor
                        renderers[renderer].AddActor(target)
                        # And push the actor into the reverseSet
                        reverseSet.append(target)
                elif operation == 'setedgecolour':
                    # Actions to set the edge colour of an actor
                    # Populate the reverseSet action
                    reverseSet[0] = "setedgecolour"
                    for target in targets:
                        # Extract the current edge colour to be pushed to the reverseSet
                        ax, ay, az = int(target[0].GetProperty().GetEdgeColor()[0]), int(target[0].GetProperty().GetEdgeColor()[1]), int(target[0].GetProperty().GetEdgeColor()[2])
                        currentAngle = (ax * 100) + (ay * 10) + (az)
                        reverseSet.append([target[0], int(currentAngle)])
                        # Set the edge of the actor to the setting from the operationSet
                        # Cast the angle value to a string
                        angleList = list(str(target[1]))
                        # Prepend 0s if necessary
                        if len(angleList) == 1:
                            angleList.insert(0, 0)
                        if len(angleList) == 2:
                            angleList.insert(0, 0)
                        # Convert the string to single digits
                        r, g, b = angleList
                        r = int(r)
                        g = int(g)
                        b = int(b)
                        # And embed the angle in the edgecolor property of the object
                        target[0].GetProperty().SetEdgeColor((r, g, b))

                elif operation == "UI":
                    # Actions to change the state of the UI inputs
                    # Capture the current settings in the reverseSet
                    reverseSet[0] = "UI"
                    currentUISettings = self.saveUI()
                    # And append the dictionary into the set
                    reverseSet.append(currentUISettings)

                    # Reset the UI from the operationSet
                    # targets[0] is the dictionary of previous settings
                    self.writeUI(targets[0])

                else:
                    # Other undo/redo options are around changing colours on the actors
                    # Since the actors are referenced in targets[0] we capture their current colours
                    targetActorColours = targets[0].GetProperty().GetColor()
                    if targetActorColours == colours['floorGoal']:
                        reverseAction = 'floorgoaltrue'
                    if targetActorColours == colours['floorEntry']:
                        reverseAction = 'floorentrytrue'
                    if targetActorColours == colours['floorInert']:
                        reverseAction = 'floorinerttrue'
                    if targetActorColours == colours['floorElement']:
                        reverseAction = 'floorelementtrue'
                    if targetActorColours == colours['intWallGoal']:
                        reverseAction = 'intgoaltrue'
                    if targetActorColours == colours['extWallGoal']:
                        reverseAction = 'extgoaltrue'
                    if targetActorColours == colours['intWallEntry']:
                        reverseAction = 'intentrytrue'
                    if targetActorColours == colours['extWallEntry']:
                        reverseAction = 'extentrytrue'
                    if targetActorColours == colours['intWallInert']:
                        reverseAction = 'intinerttrue'
                    if targetActorColours == colours['extWallInert']:
                        reverseAction = 'extinerttrue'
                    if targetActorColours == colours['obstacleInert']:
                        reverseAction = 'obsinerttrue'
                    if targetActorColours == colours['obstacleGoal']:
                        reverseAction = 'obsgoaltrue'
                    if targetActorColours == colours['obstacleEntry']:
                        reverseAction = 'obsentrytrue'
                    # Populate the reverseSet action
                    reverseSet[0] = reverseAction

                    # Get the current transparency setting
                    if self.transparencyWall.isChecked() == True:
                        opacity = opacities['transparent']
                    else:
                        opacity = opacities['opaque']

                    # Set opacity for the target object to opaque by default, and override to respect the opacity toggle only where necessary below
                    targets[0].GetProperty().SetOpacity(opacities['opaque'])

                    # Now make the change to the scene
                    if operation == "obsinerttrue":
                        # Populate the reverseSet action
                        # reverseSet[0] = reverseAction
                        targets[0].GetProperty().SetColor(colours['obstacleInert'])

                    if operation == "obsgoaltrue":
                        # Populate the reverseSet action
                        # reverseSet[0] = reverseAction
                        targets[0].GetProperty().SetColor(colours['obstacleGoal'])

                    if operation == "obsentrytrue":
                        # Populate the reverseSet action
                        # reverseSet[0] = reverseAction
                        targets[0].GetProperty().SetColor(colours['obstacleEntry'])

                    if operation == "floorgoaltrue":
                        # Populate the reverseSet action
                        # reverseSet[0] = reverseAction
                        targets[0].GetProperty().SetColor(colours['floorGoal'])

                    if operation == "floorinerttrue":
                        # Populate the reverseSet action
                        # reverseSet[0] = reverseAction
                        targets[0].GetProperty().SetColor(colours['floorInert'])

                    if operation == "floorentrytrue":
                        # Populate the reverseSet action
                        # reverseSet[0] = reverseAction
                        targets[0].GetProperty().SetColor(colours['floorEntry'])

                    if operation == "floorelementtrue":
                        # Populate the reverseSet action
                        # reverseSet[0] = reverseAction
                        targets[0].GetProperty().SetColor(colours['floorElement'])

                    if operation == "intgoaltrue":
                        # Populate the reverseSet action
                        # reverseSet[0] = reverseAction
                        targets[0].GetProperty().SetColor(colours['intWallGoal'])

                    if operation == "intentrytrue":
                        # Populate the reverseSet action
                        # reverseSet[0] = reverseAction
                        targets[0].GetProperty().SetColor(colours['intWallEntry'])

                    if operation == "intinerttrue":
                        # Populate the reverseSet action
                        # reverseSet[0] = reverseAction
                        targets[0].GetProperty().SetColor(colours['intWallInert'])
                        targets[0].GetProperty().SetOpacity(opacity)

                    if operation == "extgoaltrue":
                        # Populate the reverseSet action
                        # reverseSet[0] = reverseAction
                        targets[0].GetProperty().SetColor(colours['extWallGoal'])

                    if operation == "extentrytrue":
                        # Populate the reverseSet action
                        # reverseSet[0] = reverseAction
                        targets[0].GetProperty().SetColor(colours['extWallEntry'])

                    if operation == "extinerttrue":
                        # Populate the reverseSet action
                        # reverseSet[0] = reverseAction
                        targets[0].GetProperty().SetColor(colours['extWallInert'])
                        targets[0].GetProperty().SetOpacity(opacity)

                    # And save the modified object into the reverseSet
                    reverseSet.append(targets[0])

                # And now push the reverseSet into the reverseCollection
                reverseCollection.append(reverseSet)
            # Finally, push the completed reverseCollection into the reverseStack
            reverseStack.append(reverseCollection)
            # Update the progress bar
            iteration += 1
            percentComplete = int(iteration / ((numberOfOperations + 1) * 100))
            self.progressBar.setProperty("value", percentComplete)
            # And update the renderer
            self.renwin.Render()

    def deleteAllActors(self):
        # Delete visuals and unselect buttons
        # Prep the undoCollection
        undoCollection = []
        # Prep undoSets
        undoSetWalls = ['addactor', blocks]
        undoSetFloor = ['addactor', blocks]
        undoSetUI = ['UI', 99]
        currentUISettings = {}
        # Get the wall props
        wallProps = scanScene.get_wall_props(renderers, blocks)
        for currentProp in wallProps:
            # Push this into the undoSet
            undoSetWalls.append(currentProp)
            # Remove the prop from the renderer
            renderers[blocks].RemoveActor(currentProp)
        # Get the floor actors
        floorActors = scanScene.get_floor_actors(renderers, blocks)
        for currentActor in floorActors:
            # Push this into the undoSet
            undoSetFloor.append(currentActor)
            # Remove the actor from the renderer
            renderers[blocks].RemoveActor(currentActor)
        # Get the current UI settings to a dictionary
        currentUISettings = self.saveUI()
        undoSetUI.append(currentUISettings)
        # And overwrite the UI with the default settings
        self.writeUI(self.defaultUI)
        # After all the operations are completed, encapsulate the undoSets into an undoCollection, and push the undoCollection to the undoStack
        undoCollection.append(undoSetUI)
        undoCollection.append(undoSetFloor)
        undoCollection.append(undoSetWalls)
        # And push the undoCollection into the undoStack
        commitAction(undoCollection)
        # Don't forget to update the renderer
        self.renwin.Render()

    def walls_floor(self, style):
        # Setup
        undoSet = []
        undoCollection = []

        if style == 'addfloor':
            undoSet = floormethods.addFloor(renderers, blocks, self.progressBar)
        if style == 'removefloor':
            undoSet = floormethods.removeFloor(renderers, blocks)
        if style == 'out':
            undoCollection = add_walls.setWalls(self.renwin, renderers, blocks, int(self.roomX.value()), int(self.roomY.value()), int(self.roomZ.value()), self.progressBar, self.showCoords, self.floor, self.transparencyWall)
        if style == '2X':
            undoSet = add_walls.setInWalls_2X(self.renwin, renderers, blocks, int(self.wallParallel2X_W.value()), int(self.wallParallel2X_D.value()), int(self.wallParallel2X_H.value()), self.progressBar, self.showCoords, self.transparencyWall)
        if style == '2Z':
            undoSet = add_walls.setInWalls_2Z(self.renwin, renderers, blocks, int(self.wallParallel2Z_W.value()), int(self.wallParallel2Z_D.value()), int(self.wallParallel2Z_H.value()), self.progressBar, self.showCoords, self.transparencyWall)
        if style == 'obstacle':
            undoSet = self.saveObstacleFromSpinners(renderers, blocks, int(self.obstacleX.value()), int(self.obstacleY.value()), int(self.obstacleZ.value()), self.transparencyWall)
        if style == 'truncate':
            undoSet = add_walls.truncateWalls(self.renwin, renderers, blocks, int(self.roomY.value()), self.progressBar, self.showCoords)

        # After all the operations are completed, encapsulate the undoSet into an undoCollection, and push
        # the undoCollection to the undoStack
        # If there is something in the undoSet that is

        if len(undoCollection) > 0:
            commitAction(undoCollection)

        if len(undoSet) > 2:
            undoCollection = []
            undoCollection.append(undoSet)
            commitAction(undoCollection)
        self.renwin.Render()

    def findSceneCenter(self):
        # Get the scene bounds
        maxLength, maxWidth, minLength, minWidth = scanScene.get_scene_bounds(renderers, blocks)
        # now we have the minimum and maximum of the scene
        x_center = (maxLength - minLength) / 2
        z_center = (maxWidth - minWidth) / 2
        return (x_center, z_center)

    def set_view(self, posX, posY, posZ):
        # resets to a default set of settings for the camera
        x_center, z_center = self.findSceneCenter()
        self.camera.SetFocalPoint(x_center, 0, z_center)
        self.camera.SetPosition(posX, posY, posZ)
        self.camera.OrthogonalizeViewUp()
        renderers[0].ResetCamera()
        self.renwin.Render()
        return

    def saveObstacleFromSpinners(self, renderers, blocks, obstX, obstMaxY, obstZ, transparencyRef):
        showCoordsBool = self.showCoords.isChecked()
        wallsTransparentBool = transparencyRef.isChecked()
        # Prep undoSet
        undoSet = ['removeactor', blocks]
        for objPosY in range(obstMaxY):
            actorcube = graphics.cube_from_source(obstX, objPosY, obstZ, showCoordsBool, 'obstacleInert', False)
            renderers[blocks].AddActor(actorcube)
            # Add the new prop to the undoSet as well
            undoSet.append(actorcube)

        # If the coordinate captions are visible then they need to be reset as the lower blocks with
        # suppressed captions will now be on "top"
        if showCoordsBool == True:
            annotate.toggleCaptions(self.renwin, renderers, blocks, self.showCoords, self.progressBar, "")

        # Remove any existing pointers by clearing that renderer
        renderers[pointers].RemoveAllViewProps()
        self.disconnectAllSpinners()
        self.setObstacle.setChecked(False)
        self.iren.SetInteractorStyle(self.style)
        self.renwin.Render()

        return undoSet

    def changeTypeFromSpinners(self, spinX, spinY, spinZ, angle):
        # Based on the planning combo box status, affect the object at the location defined in the planning spinners
        # Choose a colour tuple based on the index
        # Get the current index of the planning combo box
        targetAction = self.planningComboBox.currentText()
        # Prep undoCollection and undoSets
        undoCollection = []
        undoActorColours = ['', 0]
        undoEdgeColours = ['', 0]
        # Perform a pick on the blocks renderer at the given position
        # First check with the integers from the spinner to see if there is a wall object there
        picker = vtk.vtkPropPicker()
        wallTarget = picker.Pick3DPoint((spinX, spinY, spinZ), renderers[blocks])
        if (wallTarget == 1):
            # Something was picked at the integer X, Y, Z position set in the spinners
            # Create a propCollection and iterate to isolate the cube actor
            numberOfActors = picker.GetViewProp().GetNumberOfPaths()
            # setup a vtkPropAssembly to store the assembly of parts that make up the current prop, and populate it
            actorCollection = vtk.vtkPropAssembly()
            actorCollection = picker.GetViewProp().GetParts()
            # and initiate traversal over the collection of parts/actors
            actorCollection.InitTraversal()
            for actor in range(numberOfActors):
                # now iterate over each actor
                # move to the next actor in the collection
                currentActor = actorCollection.GetNextProp()
                # check if this actor is an actor type
                typeBool = currentActor.IsTypeOf("vtkOpenGLActor")
                if typeBool == 1:
                    # This actor is the cube, and not the embedded caption
                    # Use the colour of the object to determine the current state, set the target object
                    # type, populate the undoset
                    currentActorColours = currentActor.GetProperty().GetColor()
                    if currentActorColours == colours['intWallGoal']:
                        undoActorColours[0] = 'intgoaltrue'
                        objType = 'intWall'
                    if currentActorColours == colours['extWallGoal']:
                        undoActorColours[0] = 'extgoaltrue'
                        objType = 'extWall'
                    if currentActorColours == colours['intWallEntry']:
                        undoActorColours[0] = 'intentrytrue'
                        objType = 'intWall'
                    if currentActorColours == colours['extWallEntry']:
                        undoActorColours[0] = 'extentrytrue'
                        objType = 'extWall'
                    if currentActorColours == colours['intWallInert']:
                        undoActorColours[0] = 'intinerttrue'
                        objType = 'intWall'
                    if currentActorColours == colours['extWallInert']:
                        undoActorColours[0] = 'extinerttrue'
                        objType = 'extWall'
                    if currentActorColours == colours['obstacleInert']:
                        undoActorColours[0] = 'obsinerttrue'
                        objType = 'obstacle'
                    if currentActorColours == colours['obstacleGoal']:
                        undoActorColours[0] = 'obsgoaltrue'
                        objType = 'obstacle'
                    if currentActorColours == colours['obstacleEntry']:
                        undoActorColours[0] = 'obsentrytrue'
                        objType = 'obstacle'
                    # Save the existing actor to the undoSet
                    undoActorColours.append(currentActor)

                    # Extract the angle from the edgecolor
                    ax, ay, az = int(currentActor.GetProperty().GetEdgeColor()[0]), int(currentActor.GetProperty().GetEdgeColor()[1]), int(currentActor.GetProperty().GetEdgeColor()[2])
                    currentAngle = (ax * 100) + (ay * 10) + (az)
                    # And save the existing angle
                    undoEdgeColours[0] = 'setedgecolour'
                    undoEdgeColours.append([currentActor, int(currentAngle)])

                    # Get the current transparency setting
                    if self.transparencyWall.isChecked() == True:
                        opacity = opacities['transparent']
                    else:
                        opacity = opacities['opaque']

                    if targetAction == "Clear":
                        # Reset the object to inert wall
                        if objType == 'intWall':
                            currentActor.GetProperty().SetColor(colours['intWallInert'])
                        if objType == 'extWall':
                            currentActor.GetProperty().SetColor(colours['extWallInert'])
                        if objType == 'obstacle':
                            currentActor.GetProperty().SetColor(colours['obstacleInert'])
                        # Regardless of the type, set the current opacity
                        currentActor.GetProperty().SetOpacity(opacity)
                    else:
                        if targetAction == "Set goals":
                            if objType == 'intWall':
                                currentActor.GetProperty().SetColor(colours['intWallGoal'])
                            if objType == 'extWall':
                                currentActor.GetProperty().SetColor(colours['extWallGoal'])
                            if objType == 'obstacle':
                                currentActor.GetProperty().SetColor(colours['obstacleGoal'])
                            # Regardless of the type, set the current opacity
                            currentActor.GetProperty().SetOpacity(opacities['opaque'])
                        if targetAction == "Set entries":
                            if objType == 'intWall':
                                currentActor.GetProperty().SetColor(colours['intWallEntry'])
                            if objType == 'extWall':
                                currentActor.GetProperty().SetColor(colours['extWallEntry'])
                            if objType == 'obstacle':
                                currentActor.GetProperty().SetColor(colours['obstacleEntry'])
                            # Regardless of the type, set the current opacity
                            currentActor.GetProperty().SetOpacity(opacities['opaque'])
                        # Set the unused edge colour to reflect the angle passed in as self.angle
                        # Cast the angle value to a string
                        angleList = list(str(angle))
                        # Prepend 0s if necessary
                        if len(angleList) == 1:
                            angleList.insert(0, 0)
                        if len(angleList) == 2:
                            angleList.insert(0, 0)
                        # Convert the string to single digits
                        r, g, b = angleList
                        r = int(r)
                        g = int(g)
                        b = int(b)
                        # And embed the angle in the edgecolor property of the object
                        currentActor.GetProperty().SetEdgeColor((r, g, b))
        elif (wallTarget == 0):
            # Nothing was picked at the wall elevation, so do the pick again at the floor elevation and see if there is a floor there
            floorTarget = picker.Pick3DPoint((spinX, spinY - 0.5005, spinZ), renderers[blocks])
            if floorTarget == 1:
                # The selection was on a floor object, the select the associated actor
                pickedActor = picker.GetActor()
                # Use the colour of the object to determine
                pickedActorColours = pickedActor.GetProperty().GetColor()
                if pickedActorColours == colours['floorGoal']:
                    undoActorColours[0] = 'floorgoaltrue'
                if pickedActorColours == colours['floorEntry']:
                    undoActorColours[0] = 'floorentrytrue'
                if pickedActorColours == colours['floorInert']:
                    undoActorColours[0] = 'floorinerttrue'
                if pickedActorColours == colours['floorElement']:
                    undoActorColours[0] = 'floorelementtrue'
                undoActorColours.append(pickedActor)

                # Extract the angle from the edgecolor
                ax, ay, az = int(pickedActor.GetProperty().GetEdgeColor()[0]), int(pickedActor.GetProperty().GetEdgeColor()[1]), int(pickedActor.GetProperty().GetEdgeColor()[2])
                currentAngle = (ax * 100) + (ay * 10) + (az)
                undoEdgeColours[0] = 'setedgecolour'
                undoEdgeColours.append([pickedActor, int(currentAngle)])

                if targetAction == "Clear":
                    if spinY == 0:
                        pickedActor.GetProperty().SetColor(colours['floorInert'])
                    else:
                        renderers[blocks].RemoveActor(pickedActor)
                else:
                    if targetAction == "Set goals":
                        pickedActor.GetProperty().SetColor(colours['floorGoal'])
                    if targetAction == "Set entries":
                        pickedActor.GetProperty().SetColor(colours['floorEntry'])
                    if targetAction == "Set elements":
                        pickedActor.GetProperty().SetColor(colours['floorElement'])
                        
                    # Set the unused edge colour to reflect the angle passed in as self.angle
                    # Cast the angle value to a string
                    angleList = list(str(angle))
                    # Prepend 0s if necessary
                    if len(angleList) == 1:
                        angleList.insert(0, 0)
                    if len(angleList) == 2:
                        angleList.insert(0, 0)
                    # Convert the string to single digits
                    r, g, b = angleList
                    r = int(r)
                    g = int(g)
                    b = int(b)
                    # And embed the angle in the edgecolor property of the object
                    pickedActor.GetProperty().SetEdgeColor((r, g, b))
            else:
                # Nothing was picked at the wall or floor elevation so we assume it's intended to be a flying target
                # Only create elevated goals, not elevated entries
                if targetAction == "Set goals":
                    # Create a floor panel goal style at the noted elevation
                    undoActorColours[0] = 'removeActor'
                    actorpanel = graphics.floor_panel([spinX, spinY - 0.5005, spinZ], 1, 1)
                    # Add the floor panel to the renderer
                    renderers[blocks].AddActor(actorpanel)
                    # Set the new panel to be a goal
                    actorpanel.GetProperty().SetColor(colours['floorGoal'])

                    # Set the unused edge colour to reflect the angle passed in as self.angle
                    # Cast the angle value to a string
                    angleList = list(str(angle))
                    # Prepend 0s if necessary
                    if len(angleList) == 1:
                        angleList.insert(0, 0)
                    if len(angleList) == 2:
                        angleList.insert(0, 0)
                    # Convert the string to single digits
                    r, g, b = angleList
                    r = int(r)
                    g = int(g)
                    b = int(b)
                    # And embed the angle in the edgecolor property of the object
                    actorpanel.GetProperty().SetEdgeColor((r, g, b))
                    # # Add this new panel to the undoset
                    undoActorColours.append(actorpanel)
                if targetAction == "Set entries":
                    print("Current design parameters do not permit elevated entry points")

        # After all the operations are completed, encapsulate the undoSets into an undoCollection,
        # and push the undoCollection to the undoStack
        undoCollection.append(undoActorColours)
        undoCollection.append(undoEdgeColours)
        commitAction(undoCollection)

        # After clicking on the save button, exit to standard style
        self.planningComboBox.setCurrentIndex(0)
        self.disconnectAllSpinners()
        self.iren.SetInteractorStyle(self.style)
        self.renwin.Render()

    def Keypress(self, obj, event):
        key = obj.GetKeySym()

        if key == "a":
            annotate.set_axis(self.renwin, renderers, annotations, self.axis, self.axes, "key")
        elif key == "c":
            annotate.toggleCaptions(self.renwin, renderers, blocks, self.showCoords, self.progressBar, "key")
        elif key == "d":
            self.deleteAllActors()
        elif key == "e":
            sys.exit()
        elif key == "g":
            annotate.set_grid(self.renwin, renderers, annotations, self.grid, self.gridG, "key")
        elif key == "t":
            self.walls_floor("truncate")
        elif key == "p":
            self.writefile()
        elif key == "y":
            self.undoredo('redo')
        elif key == "z":
            self.undoredo('undo')

if __name__ == "__main__":

    app = QtWidgets.QApplication(sys.argv)
    file = QFile(":/dark.qss")
    file.open(QFile.ReadOnly | QFile.Text)
    stream = QTextStream(file)
    app.setStyleSheet(stream.readAll())

    window = MainWindow()
    window.show()
    sys.exit(app.exec_())